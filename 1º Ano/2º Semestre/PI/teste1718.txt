=========================================================
PARTE A
=========================================================


1.

int retiraNeg(int v[], int N)
{
	int count = 0;
	int i;

	for(i = 0; i < N - count; i++)
	{
		if(v[i] < 0)
		{
			int j;
			for(j = i + 1; j < N - count; j++)
			{
				v[j - 1] = v[j];
			}
			++count;
		}
	}

	return count;
}


2.

int difConsecutivos(char s[])
{
	int ans = 1, i = 0;

	for(i = 0; s[i]; i++)
	{
		int count[256];
		int h;
		for(h = 0; h < 256; h++)
			count[h] = 0;

		int j;
		for(j = i; count[s[j]] == 0; j++)
		{
			count[s[j]]++;
		}

		ans = (ans < j - i) ? j - i : ans;
	}

	return ans;
}


3.

int maximo(LInt l)
{
	int ans = l->valor;

	while(l)
	{
		ans = (ans < l->valor) ? l->valor : ans;
		l = l->prox;
	}

	return ans;
}


4.

int removeAll (LInt *l, int x)
{
	int count = 0;

	LInt prev = NULL;
	while(*l)
	{
		if((*l)->valor == x)
		{
			if(prev)
			{
				prev->prox = (*l)->prox;
				free(*l);
				*l = prev;
			}
			else
			{
				LInt temp = (*l)->prox;
				free(*l);
				*l = temp;
				continue;
			}
		}
		prev = *l;
		l = &(*l)->prox;
	}

	return count;
}


5.

LInt newList(LInt l, int x)
{
	LInt res = malloc(sizeof(struct slist));

	res->valor = x;
	res->prox = l;

	return res;
}

LInt arrayToList (int v[], int N)
{
	LInt res = NULL;
	int i;
	for(i = N - 1; i >= 0; i--)
	{
		res = newList(res, v[i]);
	}

	return res;
}


=========================================================
PARTE B
=========================================================


1.

int minheapOKAux(ABin a, int* x)
{
	if(a == NULL)
		return 1;

	int left, right;

	int res = minheapOKAux(a->esq, &left) && minheapOKAux(a->dir, &right);

	if(res)
	{
		if(left > a->valor && right > a->valor) 
		{
			*x = a;
		}
		else
		{
			res = 0;
		}
	}

	return res;
}

int minheapOK (ABin a)
{
	int x;
	return minheapOKAux(a, &x);
}


2.

#define max(a,b) ((a < b) ? b : a)

int maxHeap (ABin a)
{
	int res = a->valor;

	if(a->esq)
		res = max(res, maxHeap(a->esq));

	if(a->dir)
		res = max(res, maxHeap(a->dir));

	return res;
}


3.

#define max(a,b) ((a > b) ? b : a)

void removeMin (ABin *a)
{
	if(*a == NULL)
		return;

	if(!(*a)->esq && !(*a)->dir)
	{
		free(*a);
		*a = NULL;
	}
	else
	{
		if((*a)->esq && (*a)->dir)
		{
			if((*a)->esq->valor < (*a)->dir->valor)
			{
				(*a)->valor = (*a)->esq->valor;
				removeMin(&(*a)->esq);
			}
			else
			{
				(*a)->valor = (*a)->dir->valor;
				removeMin(&(*a)->dir);
			}
		}
		else if((*a)->esq)
		{
			(*a)->valor = (*a)->esq->valor;
			removeMin(&(*a)->esq);
		}
		else
		{
			(*a)->valor = (*a)->dir->valor;
			removeMin(&(*a)->dir);
		}
	}
}


4. 

void heapSort (int v[], int N)
{
	ABin aux = NULL;

	int i;
	for(i = 0; i < N; i++)
		add(&aux, v[i]);


	for(i = 0; i < N; i++)
	{
		v[i] = aux->valor;
		removeMin(&aux);
	}
}


5.

int kMaior (int v[], int N, int k)
{
	ABin aux = NULL;
	int i;
	for(i = 0; i < k; i++)
		add(&aux, v[i]);

	for(i = k; i < N; i++)
		if(v[i] > aux->valor)
		{
			removeMin(&aux);
			add(&aux, v[i]);
		}

	int res = aux->valor;

	while(aux)
		removeMin(&aux);

	return res;
}