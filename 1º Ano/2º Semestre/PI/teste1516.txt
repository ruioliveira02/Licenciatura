=========================================================
						PARTE A
=========================================================

1.

char *strcat (char s1[], char s2[]) {
	int i, j;
	for(i = 0; s1[i]; i++);
	for(j = 0; s2[j]; j++)
		s1[i + j] = s2[j];

	return s1;
}



2.

int remRep (char x[])
{
	int read = 1, write = 1;

	if(!x[0])
		return 0;

	char last = x[0];

	while(x[read])
	{
		if(x[read] != last)
		{
			x[write++] = x[read];
			last = x[read];
		}
		++read;
	}

	x[write] = '\0';

	return write;
}


3.

int nivelV (ABin a, int n, int v[])
{
	if(a == NULL)
		return 0;

	if(n == 1)
	{
		*v = a->valor;
		return 1;
	}

	int left = nivelV(a->esq, n - 1, v);
	int right = nivelV(a->dir, n - 1, v + left);

	return (left + right);
}


int addOrd (ABin *a, int x)
{
	int res = 0;

	if(*a == NULL)
	{
		ABin temp = malloc(sizeof(struct nodo));
		temp->valor = x;
		temp->esq = temp->dir = NULL;
		*a = temp;
	}
	else if((*a)->valor == x)
		res = 1;
	else if((*a)->valor > x)
		res = addOrd(&(*a)->esq, x);
	else
		res = addOrd(&(*a)->dir, x);

	return res;
}


=========================================================
						PARTE B
=========================================================


1.

float getEntry (Mat m, int linha, int coluna)
{
	float res = 0.0;

	while(m->linha < linha)
		m = m->prox;

	if(m->linha == linha)
	{
		while(m->lcol->coluna < coluna)
			m->lcol = m->lcol->prox;

		if(m->lcol->coluna == coluna)
			res = m->linha->lcol->valor;
	}

	return res;
}


2.

void insereColuna(Colunas* col, int coluna, float valor)
{
	Colunas c = *col, prev = NULL;
	while(c->coluna < coluna)
	{
		prev = c;
		c = c->prox;
	}

	if(col->coluna == coluna)
	{
		col->valor = valor;
	}
	else
	{
		Colunas newCol = malloc(sizeof(struct listaC));
		newCol->coluna = coluna;
		newCol->valor = valor;
		newCol->prox = col;

		if(prev)
			prev->prox = newCol;
		else
			*col = newCol;
	}
}


void setEntry (Mat *m, int linha, int coluna, float valor)
{
	float res = 0.0;
	Mat m1 = *m;
	Mat prev = NULL;
	while(m1 && m1->linha < linha)
	{
		prev = m1;
		m1 = m1->prox;
	}

	if(m1 && m1->linha == linha)
	{
		insereColuna(&(m1->lcol), coluna, valor);
	}
	else
	{
		Mat newLine = malloc(sizeof(struct listaL));
		newLine->linha = linha;
		newLine->lcol = NULL;
		newLine->prox = m1;
		if(prev)
			prev->prox = newLine;
		else
			*m = newLine;

		insereColuna(&(newLine->lcol), coluna, valor);
	}
}


3.

Colunas deepCopy(Colunas c)
{
	if(c == NULL)
		return NULL;

	Colunas temp = malloc(sizeof(struct listaC));
	temp->coluna = c->coluna;
	temp->valor = c->valor;
	temp->prox = deepCopy(c->prox);

	return temp;
}

void sumCol(Colunas *c1, Colunas c2)
{
	if(!c2)
		return;

	if(!c1)
		*c1 = deepCopy(c2);

	if((*c1)->coluna == c2->coluna)
	{
		(*c1)->valor += c2->valor;
		sumCol(&(*c1)->prox, c2->prox);
	}
	else if((*c1)->coluna < c2->coluna)
	{
		sumCol(&(*c1)->prox, c2->prox);
	}
	else
	{
		Colunas temp = malloc(sizeof(struct listaC));
		temp->valor = c2->valor;
		temp->coluna = c2->coluna;
		temp->prox = (*c1);
		*c1 = temp;
		sumCol(&temp->prox, c2->prox);
	}
}

void addTo (Mat *m1, Mat m2)
{
	if((*m1)->linha < m2->linha)
		addTo(&(*m1)->prox; m2);
	else if((*m1)->linha == m2->linha)
	{
		sumCol(&(*m1)->lcol, m2->lcol);
		addTo(&(*m1)->prox, m2->prox);
	}
	else
	{
		Colunas temp = malloc(sizeof(struct listaL));
		temp->linha = m2->linha;
		temp->prox = *m1;

		temp->lcol = deepCopy(m2->lcol);

		*m1 = temp;
	}
}


4.

void freeCol(Colunas *c)
{
	if(*c == NULL)
		return;

	freeCol(&(*c)->prox);

	free(*c);
}

void freeMat(Mat *m)
{
	if(*m == NULL)
		return;

	freeMat(&(*m)->prox);
	freeCol(&(*m)->lcol);
	free(*m);
}

void transpose (Mat *m)
{
	Mat res = NULL;

	Mat temp = *m;


	while(temp)
	{
		int linha = temp->linha;

		while(temp->lcol)
		{
			setEntry(&res, temp->lcol->coluna, linha, temp->lcol->valor);
			temp->lcol = temp->lcol->prox;
		}
		temp = temp->prox;
	}

	freeMat(m);
	*m = res;
}